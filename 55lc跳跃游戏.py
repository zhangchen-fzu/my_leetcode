'''
#############################################################################################################
**题目55：（数组）
给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。
一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。
两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。
**示例：
输入：text1 = "abcde", text2 = "ace"
输出：3
解释：最长公共子序列是 "ace" ，它的长度为 3 。
**条件：
1 <= text1.length, text2.length <= 1000
text1 和 text2 仅由小写英文字符组成。
#############################################################################################################
'''
'''
动规方法：
能否跳到最后的位置，可转化为最大可跳跃到哪个位置。如果nums[0:-1]可跳跃的最大位置超过最后位置，说明可以跳到最后的位置。
dp定义：dp[i]表示从开始到i位置最多可跳跃到哪个位置
状态转移方程：
如果之前的跳跃可达最大位置 等于或超过当前的位置，则当前位置可跳跃的位置为i + nums[i]，可跳跃的最大位置为max(dp[i - 1], i + nums[i])
如果之前的跳跃可达最大位置 无法到达当前的位置，则当前位置可跳跃的最大位置为dp[i - 1]
base case: dp[0] = nums[0]
复杂度分析：
时间复杂度：O(N)
空间复杂度：O(N)

'''
class Solution(object):
    def canJump(self, nums):
        m = len(nums)

        if m <= 1:
            return True

        dp = [0] * (m - 1)
        dp[0] = nums[0]
        for i in range(1, m - 1):
            if dp[i-1] >= i:
                dp[i] = max(dp[i - 1], i + nums[i])
            else:
                dp[i] = dp[i - 1]
        return dp[-1] >= m - 1

'''
动规优化：
dp[i]只与dp[i - 1]有关，可用变量存储前一个值
复杂度分析：
时间复杂度：O(N)
空间复杂度：O(1)
'''
class Solution(object):
    def canJump(self, nums):
        m = len(nums)
        dp_pre=nums[0]
        for i in range(1, m - 1):
            if dp_pre >= i:
                dp_pre = max(dp_pre, i + nums[i])
        return dp_pre >= m - 1