'''
#############################################################################################################
**题目：10（数组）
给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。
'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。

**示例：
输入：s = "aa" p = "a"
输出：false
解释："a" 无法匹配 "aa" 整个字符串。
**条件：
0 <= s.length <= 20
0 <= p.length <= 30
s 可能为空，且只包含从 a-z 的小写字母。
p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。
保证每次出现字符 * 时，前面都匹配到有效的字符
#############################################################################################################
'''
'''
dp定义：dp[i][j]表示s从0开始到i位置及p从0开始到j位置的匹配情况
状态转移方程：
如果s[i]与p[j]或p[j]是一个单通配符“.”相等，则继续处理下一个
如果p[j]是多通配符"*"，检查通配符的前一个字符p[j-1]是否与s[i]相同，
    如果不相同，则该通配符及前一个字符一定是无用的，接下来匹配s[i]与p[j-2]
    如果相同，有三种情况，发生其中的一种即可认为是匹配成功
        该通配符及前一个字符与s中的一个字符匹配：需检查s[i]与p[j-1]的情况
        该通配符及前一个字符与s中的多个字符匹配：需检查s[i-1]与p[j]的情况
        该通配符及前一个字符是无用的：需检查s[i]与p[j-2]的情况
base case:dp的第一行及第一列：（s,p）
    第一行：当在p的奇数位置一直出现*时，则p可与空字符匹配
    第一列：除dp[0][0]外，其余值全部为False
    其他部分：待求
复杂度分析：
时间复杂度：O(M*N)
空间复杂度：O(M*N)
'''
class Solution(object):
    def isMatch(self, s, p):
        m = len(s)
        n = len(p)
        dp=[[False] * (n + 1) for _ in range(m + 1)]

        dp[0][0] = True
        for i in range(2, n + 1, 2):
            if p[i - 1] == '*':
                dp[0][i] = dp[0][i - 2]

        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if s[i - 1] == p[j - 1] or p[j - 1] == '.':
                    dp[i][j] = dp[i - 1][j - 1]
                elif p[j - 1] == '*':
                    if p[j - 2] == s[i - 1] or p[j - 2] == '.':
                        dp[i][j] = dp[i][j - 1] or dp[i - 1][j] or dp[i][j - 2]
                    else:
                        dp[i][j] = dp[i][j - 2]
        return dp[m][n]
'''
动规优化：
dp[i][j]与dp[i-1][j-1]、dp[i][j-1]、dp[i-1][j]、dp[i][j-2]有关
因此可以保留本层值及上层值两行dp
复杂度分析：
时间复杂度：O(M*N)
空间复杂度：O(N)
'''
class Solution(object):
    def isMatch(self, s, p):
        m = len(s)
        n = len(p)
        dp = [[False] * (n + 1) for _ in range(2)]

        dp[0][0] = True
        for i in range(2, n + 1, 2):
            if p[i - 1] == '*':
                dp[0][i] = dp[0][i - 2]

        for i in range(1, m + 1):
            for j in range(1,n + 1):
                if s[i - 1] == p[j - 1] or p[j - 1] == '.':
                    dp[1][j] = dp[0][j - 1]
                elif p[j - 1] == '*':
                    if p[j - 2] == s[i - 1] or p[j - 2] == '.':
                        dp[1][j] = dp[1][j - 1] or dp[0][j] or dp[1][j - 2]
                    else:
                        dp[1][j] = dp[1][j - 2]
                else:
                    dp[1][j] = False
            dp[0][:] = dp[1][:]
        return dp[1][n]